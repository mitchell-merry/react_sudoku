{"version":3,"sources":["Grid/Grid.module.scss","Sudoku/Sudoku.ts","Grid/Grid.tsx","index.tsx","index.module.scss"],"names":["module","exports","isUniqueCellSet","cells","found","cell","value","some","c","push","getRow","grid","row","o","col","N","getCol","getBox","boxRow","boxCol","i","Math","floor","getCellBox","cellsInSameRegion","one","two","boxOne","boxTwo","inSameBox","getValueAtCoordinate","coord","validGrid","valueFrequencyInSet","arr","forEach","clearGridOfState","state","rowIdx","colIdx","shuffle","length","j","random","fillGrid","generate","countAll","empty","getEmpty","solutionsFromHere","options","Array","from","_","option","sols","generateGrid","emptyCells","getAllCoordinates","temp","shift","console","log","copyGrid","map","a","slice","classNames","require","arrowToNeighbour","Grid","useState","Sudoku","setGrid","selectedCell","setSelectedCell","handleKeyDown","e","val","Number","key","isNaN","Object","keys","includes","currentSelectedCell","newCell","setCellValue","preventDefault","useEffect","curr","newGrid","document","addEventListener","removeEventListener","currVal","className","styles","shade","valueOne","cn","selected_cell","selected_number","selected_region","cell_static","cell_solved","cell_invalid","cell_top_border_soft","cell_left_border_soft","cell_top_border_hard","cell_left_border_hard","onMouseDown","currentCell","selectCell","App","app","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.8aa067b2.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Grid_grid__1_G_b\",\"row\":\"Grid_row__2i5tn\",\"cell\":\"Grid_cell__2Qb8m\",\"selected_cell\":\"Grid_selected_cell__anmyI\",\"selected_region\":\"Grid_selected_region__UIGkt\",\"selected_number\":\"Grid_selected_number__ACSJx\",\"cell_static\":\"Grid_cell_static__a53Fw\",\"cell_solved\":\"Grid_cell_solved__2rcXD\",\"cell_invalid\":\"Grid_cell_invalid__qYQ_B\",\"cell_left_border_soft\":\"Grid_cell_left_border_soft__3V9ja\",\"cell_top_border_soft\":\"Grid_cell_top_border_soft__3woQe\",\"cell_left_border_hard\":\"Grid_cell_left_border_hard__1BuMv\",\"cell_top_border_hard\":\"Grid_cell_top_border_hard__32fsp\"};","export type CellState = 'static' | 'solved' | null;\r\n\r\n// ICell, IGrid, I Fard, I Shid\r\nexport interface ICell {\r\n    value: number | null;\r\n    // Static means generated - unchanging\r\n    // Solved means when you press \"solve\" it was filled in for you\r\n    // Null means either empty or filled by the user (default)\r\n    state: CellState;\r\n}\r\n\r\nexport interface IGrid {\r\n    N: number; // N is the size of a box. The grid is a 3x3 set of boxes, essentially 3N by 3N.\r\n    grid: ICell[][];\r\n};\r\n\r\nexport type Coordinate = [row: number, col: number];\r\n\r\nconst isUniqueCellSet = (cells: ICell[]): boolean => {\r\n    const found: number[] = [];\r\n\r\n    for(const cell of cells) {\r\n        if(cell.value === null) continue;\r\n\r\n        // Duplicate found\r\n        if(found.some(c => c === cell.value)) return false;\r\n        \r\n        // If not already found, add it to the list\r\n        found.push(cell.value!);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Expanded from one-liners for readability\r\nconst getRow = (grid: IGrid, row: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let col = 0; col < grid.N*grid.N; col++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getCol = (grid: IGrid, col: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let row = 0; row < grid.N*grid.N; row++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getBox = (grid: IGrid, boxRow: number, boxCol: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        const [row, col] = [boxRow*grid.N+Math.floor(i/grid.N), boxCol*grid.N+i%grid.N];\r\n        o.push(grid.grid[row][col]);\r\n    }\r\n    return o;\r\n};\r\n\r\nexport const getCellBox = (cell: Coordinate, N: number): Coordinate => {\r\n    return [ Math.floor(cell[0]/N), Math.floor(cell[1]/N) ];\r\n}\r\n\r\nexport const inSameBox = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    const [boxOne, boxTwo] = [getCellBox(one, N), getCellBox(two, N)];\r\n    return boxOne[0] === boxTwo[0] && boxOne[1] === boxTwo[1];\r\n}\r\n\r\nexport const cellsInSameRegion = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    return one[0] === two[0] || one[1] === two[1] || inSameBox(one, two, N);\r\n}\r\n\r\nexport const coordinatesEqual = (one: Coordinate, two: Coordinate): boolean => {\r\n    return one[0] === two[0] && one[1] === two[1];\r\n}\r\n\r\nexport const getValueAtCoordinate = (coord: Coordinate, grid: IGrid): number | null => {\r\n    return grid.grid[coord[0]][coord[1]].value;\r\n}\r\n\r\nexport const cellValuesEqual = (one: Coordinate, two: Coordinate, grid: IGrid): boolean => {\r\n    const [valueOne, valueTwo] = [getValueAtCoordinate(one, grid), getValueAtCoordinate(two, grid)]\r\n    return valueOne !== null && valueOne === valueTwo;\r\n}\r\n\r\nexport const coordOOBOnGrid = (coord: Coordinate, grid: IGrid): boolean => {\r\n    return coord[0] < 0 || coord[1] < 0 || coord[0] >= grid.grid.length || coord[1] >= grid.grid[coord[0]].length;\r\n}\r\n\r\nexport const sumCoordinates = (one: Coordinate, two: Coordinate): Coordinate => {\r\n    return [one[0] + two[0], one[1] + two[1]];\r\n}\r\n\r\nexport const getAllCoordinates = (grid: IGrid): Coordinate[] => {\r\n    return Array.from({length: grid.N * grid.N*grid.N * grid.N}, (_, i) => [Math.floor(i/(grid.N*grid.N)), i%(grid.N*grid.N)]);\r\n}\r\n\r\nexport const validGrid = (grid: IGrid): boolean => {\r\n    // validate rows\r\n    for(let row = 0; row < grid.N*grid.N; row++) {\r\n        if(!isUniqueCellSet(getRow(grid, row))) return false;\r\n    }\r\n\r\n    // validate cols\r\n    for(let col = 0; col < grid.N*grid.N; col++) {\r\n        if(!isUniqueCellSet(getCol(grid, col))) return false;\r\n    }\r\n\r\n    // validate boxes\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        if(!isUniqueCellSet(getBox(grid, Math.floor(i/grid.N), i%grid.N))) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst valueFrequencyInSet = (arr: ICell[], value: number | null): number => {\r\n    let o = 0;\r\n    arr.forEach(i => {\r\n        if(i.value === value) o++;\r\n    })\r\n    \r\n    return o;\r\n}\r\n\r\nexport const isCoordinateValidOnGrid = (grid: IGrid, coord: Coordinate): boolean => {\r\n    return valueFrequencyInSet(getRow(grid, coord[0]), getValueAtCoordinate(coord, grid)) <= 1\r\n        && valueFrequencyInSet(getCol(grid, coord[1]), getValueAtCoordinate(coord, grid)) <= 1\r\n        && valueFrequencyInSet(getBox(grid, getCellBox(coord, grid.N)[0], getCellBox(coord, grid.N)[1]), getValueAtCoordinate(coord, grid)) <= 1;\r\n}\r\n\r\n// get co-ordinates of first empty cell in a grid (or null)\r\nexport const getEmpty = (grid: IGrid): [number, number] | null => {\r\n    for(let row = 0; row < grid.grid.length; row++) {\r\n        for(let col = 0; col < grid.grid[row].length; col++) {\r\n            if(grid.grid[row][col].value === null) return [row, col];\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport const clearGridOfState = (grid: IGrid, state: CellState) => {\r\n    grid.grid.forEach((row, rowIdx) => {\r\n        grid.grid[rowIdx].forEach((cell, colIdx) => {\r\n            if(grid.grid[rowIdx][colIdx].state === state) grid.grid[rowIdx][colIdx] = {value: null, state: null}; \r\n        });\r\n    });\r\n}\r\n\r\n// in place and returns the array\r\nexport const shuffle = (arr: any[]): any[] => {\r\n    for (let i = arr.length-1; i >= 0; i--) {\r\n        let j = Math.floor(Math.random() * (i+1));\r\n        [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport const fillGrid = (grid: IGrid, generate: boolean, countAll: boolean): number => {\r\n    // TODO: keep track of empty cells in IGrid rather than re-calcing on every recurse\r\n    const empty = getEmpty(grid);\r\n    if(empty === null) return 1;\r\n\r\n    const [row, col] = empty;\r\n    let solutionsFromHere = 0;\r\n\r\n    // possible values for cell\r\n    const options: number[] = Array.from({length: grid.N*grid.N}, (_, i) => i+1); \r\n    if(generate) shuffle(options);\r\n\r\n    for(const option of options) {\r\n        grid.grid[row][col] = {\r\n            value: option,\r\n            state: generate ? 'static' : 'solved'\r\n        };\r\n\r\n        if(!validGrid(grid)) continue;\r\n        const sols = fillGrid(grid, generate, countAll);\r\n        \r\n        if(!countAll && sols === 1) return sols;\r\n\r\n        solutionsFromHere += sols;\r\n    }\r\n\r\n    grid.grid[row][col] = {\r\n        value: null,\r\n        state: null\r\n    };\r\n    \r\n    return solutionsFromHere;\r\n}\r\n\r\nexport const generateGrid = (grid: IGrid, emptyCells: number): void => {\r\n\r\n    // Generate solved state and work backwards\r\n    fillGrid(grid, true, false);\r\n\r\n    const options: Coordinate[] = shuffle(getAllCoordinates(grid));\r\n    \r\n    // While there are more empty cells to remove and we haven't run out of options\r\n    while(emptyCells > 0 && options.length > 0) {\r\n\r\n        // Remove the cell at our first (random) location and store temporarily\r\n        const temp = grid.grid[options[0][0]][options[0][1]].value;\r\n        grid.grid[options[0][0]][options[0][1]] = {value: null, state: null};\r\n        \r\n        // Not a valid solution\r\n        if(fillGrid(grid, false, true) !== 1) {\r\n            // Restore value if it introduces ambiguity\r\n            grid.grid[options[0][0]][options[0][1]] = {value: temp, state: 'static'};\r\n        } else {\r\n            // Decrease the number of empty cells (remaining)\r\n            emptyCells--;\r\n\r\n            // Clear the board of solved cells (they would have been filled in when we checked)\r\n            clearGridOfState(grid, 'solved');\r\n        }\r\n\r\n        // Remove the option\r\n        options.shift();\r\n    }\r\n\r\n    console.log(grid)\r\n}\r\n\r\nexport const instantiateGrid = (N: number): IGrid => {\r\n    return {\r\n        N,\r\n        grid: Array.from({length: N*N}, (_, row) => (\r\n            Array.from({length: N*N}, (_, col) => ({ value: null, state: null }))\r\n        ))\r\n    }\r\n}\r\n\r\nexport const copyGrid = (grid: IGrid): IGrid => {\r\n    return {\r\n        N: grid.N, \r\n        grid: grid.grid.map(a => a.slice())\r\n    }\r\n}","import React, { useEffect, useState } from \"react\";\r\nimport * as Sudoku from \"../Sudoku/Sudoku\";\r\nimport styles from './Grid.module.scss';\r\nvar classNames = require('classnames');\r\n\r\nexport interface GridProps {\r\n    N: number;\r\n}\r\n\r\ninterface ATM { [key: string]: Sudoku.Coordinate }\r\n\r\nconst arrowToNeighbour: ATM = {\r\n    'ArrowUp':      [-1, 0],\r\n    'ArrowDown':    [1, 0],\r\n    'ArrowLeft':    [0, -1],\r\n    'ArrowRight':   [0, 1],\r\n};\r\n\r\nexport const Grid: React.FC<GridProps> = ({ N }) => {\r\n    const [ grid, setGrid ] = useState(Sudoku.instantiateGrid(N))\r\n    const [ selectedCell, setSelectedCell ] = useState<Sudoku.Coordinate>([0, 0]);\r\n\r\n    const handleKeyDown = (e: KeyboardEvent): void => {\r\n        const val = Number(e.key);\r\n        if(!isNaN(val)) {\r\n            e.preventDefault();    \r\n            setCellValue(selectedCell[0], selectedCell[1], val);\r\n        } else if(Object.keys(arrowToNeighbour).includes(e.key)) {\r\n            setSelectedCell(currentSelectedCell => {\r\n                const newCell = Sudoku.sumCoordinates(currentSelectedCell, arrowToNeighbour[e.key]);\r\n                if(Sudoku.coordOOBOnGrid(newCell, grid)) return currentSelectedCell\r\n                return newCell;\r\n            })\r\n        } else if(e.key === 'Delete' || e.key === 'Backspace') {\r\n            setCellValue(selectedCell[0], selectedCell[1], null);\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.copyGrid(curr);\r\n            Sudoku.generateGrid(newGrid, 45);\r\n            return newGrid;\r\n        });\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        document.addEventListener('keydown', handleKeyDown);\r\n\r\n        return () => document.removeEventListener('keydown', handleKeyDown)\r\n    }, [ selectedCell, ]);\r\n\r\n    const selectCell = (row: number, col: number): void => {\r\n        setSelectedCell(currentCell => [row, col]);\r\n    }\r\n\r\n    const setCellValue = (row: number, col: number, value: number | null): void => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.copyGrid(curr);\r\n\r\n            if(newGrid.grid[row][col].state !== 'static') {\r\n                const currVal = Sudoku.getValueAtCoordinate([row, col], newGrid);\r\n                if(currVal === value || value === 0) newGrid.grid[row][col].value = null;\r\n                else newGrid.grid[row][col].value = value;\r\n            }\r\n            \r\n            return newGrid;\r\n        });\r\n    }\r\n\r\n    // Row by row\r\n    return <div className={styles.grid}>\r\n        {grid.grid.map((row, rowIdx) => <div className={styles.row} key={rowIdx}>{\r\n            row.map((cell, colIdx) => {\r\n                \r\n                const shade = Sudoku.coordinatesEqual(selectedCell, [rowIdx, colIdx]) ? 'coordinate'\r\n                            : Sudoku.cellValuesEqual(selectedCell, [rowIdx, colIdx], grid) ? 'number'\r\n                            : Sudoku.cellsInSameRegion(selectedCell, [rowIdx, colIdx], grid.N) ? 'region'\r\n                            : null;\r\n\r\n                const state = Sudoku.isCoordinateValidOnGrid(grid, [rowIdx, colIdx]) ? cell.state\r\n                            : 'invalid';\r\n                            \r\n                let cn = classNames(\r\n                    // Base style\r\n                    styles.cell,\r\n\r\n                    // Selected cell and region\r\n                    {[styles.selected_cell]: shade === 'coordinate'},\r\n                    {[styles.selected_number]: shade === 'number'},\r\n                    {[styles.selected_region]: shade === 'region'},\r\n\r\n                    // Cell type\r\n                    {[styles.cell_static]: state === 'static'},\r\n                    {[styles.cell_solved]: state === 'solved'},\r\n                    {[styles.cell_invalid]: state === 'invalid'},\r\n\r\n                    // Borders\r\n                    {[styles.cell_top_border_soft]: rowIdx % grid.N !== 0},\r\n                    {[styles.cell_left_border_soft]: colIdx % grid.N !== 0},\r\n                    {[styles.cell_top_border_hard]: rowIdx % grid.N === 0},\r\n                    {[styles.cell_left_border_hard]: colIdx % grid.N === 0}, \r\n                );\r\n                \r\n                return <div className={cn} key={`${rowIdx} ${colIdx}`} onMouseDown={() => selectCell(rowIdx, colIdx)}>\r\n                    {cell.value}\r\n                </div>}\r\n            )\r\n        }</div>)}\r\n    </div>\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './document.css';\nimport styles from './index.module.scss';\nimport { Grid } from './Grid/Grid';\n\nexport const App: React.FC = () => {\n \n  return <div className={styles.app}>\n    <Grid N={3}/>\n  </div>\n}\n\n// Inject\nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"src_app__71Sw-\"};"],"sourceRoot":""}