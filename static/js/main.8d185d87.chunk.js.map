{"version":3,"sources":["Grid/Grid.module.scss","Sudoku/Sudoku.ts","Grid/Grid.tsx","index.tsx","index.module.scss"],"names":["module","exports","getCellBox","cell","N","Math","floor","cellsInSameRegion","one","two","boxOne","boxTwo","inSameBox","classNames","require","Grid","useState","grid","Array","from","length","_","row","col","value","instantiateGrid","selectedCell","setSelectedCell","useEffect","className","styles","map","rowIdx","colIdx","state","cn","selected_region","selected_cell","cell_top_border_soft","cell_left_border_soft","cell_top_border_hard","cell_left_border_hard","onMouseDown","currentCell","selectCell","App","app","ReactDOM","render","document","getElementById"],"mappings":"+FACAA,EAAOC,QAAU,CAAC,KAAO,mBAAmB,IAAM,kBAAkB,KAAO,mBAAmB,cAAgB,4BAA4B,gBAAkB,8BAA8B,sBAAwB,oCAAoC,qBAAuB,mCAAmC,sBAAwB,oCAAoC,qBAAuB,qC,iKC8E7XC,G,KAAa,SAACC,EAAkBC,GAClC,MAAO,CAAEC,KAAKC,MAAMH,EAAK,GAAGC,GAAIC,KAAKC,MAAMH,EAAK,GAAGC,MAQ1CG,EAAoB,SAACC,EAAiBC,EAAiBL,GAChE,OAAOI,EAAI,KAAOC,EAAI,IAAMD,EAAI,KAAOC,EAAI,IAN7B,SAACD,EAAiBC,EAAiBL,GACjD,MAAyB,CAACF,EAAWM,EAAKJ,GAAIF,EAAWO,EAAKL,IAAvDM,EAAP,KAAeC,EAAf,KACA,OAAOD,EAAO,KAAOC,EAAO,IAAMD,EAAO,KAAOC,EAAO,GAINC,CAAUJ,EAAKC,EAAKL,I,uBCtFrES,EAAaC,EAAQ,IAMZC,EAA4B,SAAC,GAAW,IAATX,EAAQ,EAARA,EACxC,EAA0BY,mBDkIC,SAACZ,GAC5B,MAAO,CACHA,IACAa,KAAMC,MAAMC,KAAK,CAACC,OAAQhB,EAAEA,IAAI,SAACiB,EAAGC,GAAJ,OAC5BJ,MAAMC,KAAK,CAACC,OAAQhB,EAAEA,IAAI,SAACiB,EAAGE,GAAJ,MAAa,CAACC,MAAO,aCtIpBC,CAAgBrB,IAAnD,mBAAQa,EAAR,KACA,GADA,KAC0CD,mBAAqB,CAAC,EAAG,KAAnE,mBAAQU,EAAR,KAAsBC,EAAtB,KAEAC,qBAAU,cAMP,IAOH,OAAO,qBAAKC,UAAWC,IAAOb,KAAvB,SACFA,EAAKA,KAAKc,KAAI,SAACT,EAAKU,GAAN,OAAiB,qBAAKH,UAAWC,IAAOR,IAAvB,SAC5BA,EAAIS,KAAI,SAAC5B,EAAM8B,GAIX,ID4DiBzB,EAAiBC,EC5D5ByB,GD4D4BzB,EC5DW,CAACuB,EAAQC,ID4DrCzB,EC5DckB,GD6DhC,KAAOjB,EAAI,IAAMD,EAAI,KAAOC,EAAI,GC7DkC,EAClDF,EAAkBmB,EAAc,CAACM,EAAQC,GAAShB,EAAKb,GAAK,EAC7D,GAEV+B,EAAKtB,EAELiB,IAAO3B,KAFQ,eAKb2B,IAAOM,gBAA4B,IAAVF,GALZ,eAMbJ,IAAOO,cAA0B,IAAVH,GANV,eASbJ,IAAOQ,qBAAuBN,EAASf,EAAKb,IAAM,GATrC,eAUb0B,IAAOS,sBAAwBN,EAAShB,EAAKb,IAAM,GAVtC,eAWb0B,IAAOU,qBAAuBR,EAASf,EAAKb,IAAM,GAXrC,eAYb0B,IAAOW,sBAAwBR,EAAShB,EAAKb,IAAM,IAEzD,OAAO,qBAAKyB,UAAWM,EAAgCO,YAAa,kBA7B7D,SAACV,EAAgBC,GAChCN,GAAgB,SAAAgB,GAAW,MAAI,CAACX,EAAQC,MA4B0CW,CAAWZ,EAAQC,IAAtF,SACF9B,EAAKqB,OADH,UAA4BQ,EAA5B,YAAsCC,QAvBYD,SCrB5Da,EAAgB,WAE3B,OAAO,qBAAKhB,UAAWC,IAAOgB,IAAvB,SACL,cAAC,EAAD,CAAM1C,EAAG,OAKb2C,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,U,kBCf1BlD,EAAOC,QAAU,CAAC,IAAM,oB","file":"static/js/main.8d185d87.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Grid_grid__1_G_b\",\"row\":\"Grid_row__2i5tn\",\"cell\":\"Grid_cell__2Qb8m\",\"selected_cell\":\"Grid_selected_cell__anmyI\",\"selected_region\":\"Grid_selected_region__UIGkt\",\"cell_left_border_soft\":\"Grid_cell_left_border_soft__3V9ja\",\"cell_top_border_soft\":\"Grid_cell_top_border_soft__3woQe\",\"cell_left_border_hard\":\"Grid_cell_left_border_hard__1BuMv\",\"cell_top_border_hard\":\"Grid_cell_top_border_hard__32fsp\"};","// ICell, IGrid, I Fard, I Shid\r\nexport interface ICell {\r\n    value: number | null;\r\n}\r\n\r\nexport interface IGrid {\r\n    N: number; // N is the size of a box. The grid is a 3x3 set of boxes, essentially 3N by 3N.\r\n    grid: ICell[][];\r\n};\r\n\r\nexport type Coordinate = [row: number, col: number];\r\n\r\nconst isUniqueCellSet = (cells: ICell[]): boolean => {\r\n    const found: number[] = [];\r\n\r\n    for(const cell of cells) {\r\n        if(cell.value === null) continue;\r\n\r\n        // Duplicate found\r\n        if(found.some(c => c === cell.value)) return false;\r\n        \r\n        // If not already found, add it to the list\r\n        found.push(cell.value!);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Expanded from one-liners for readability\r\nconst getRow = (grid: IGrid, row: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let col = 0; col < grid.N*grid.N; col++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getCol = (grid: IGrid, col: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let row = 0; row < grid.N*grid.N; row++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getBox = (grid: IGrid, boxRow: number, boxCol: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        const [row, col] = [boxRow*grid.N+Math.floor(i/grid.N), boxCol*grid.N+i%grid.N];\r\n        o.push(grid.grid[row][col]);\r\n    }\r\n    return o;\r\n};\r\n\r\nexport const validGrid = (grid: IGrid): boolean => {\r\n    // validate rows\r\n    for(let row = 0; row < grid.N*grid.N; row++) {\r\n        if(!isUniqueCellSet(getRow(grid, row))) return false;\r\n    }\r\n\r\n    // validate cols\r\n    for(let col = 0; col < grid.N*grid.N; col++) {\r\n        if(!isUniqueCellSet(getCol(grid, col))) return false;\r\n    }\r\n\r\n    // validate boxes\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        if(!isUniqueCellSet(getBox(grid, Math.floor(i/grid.N), i%grid.N))) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// get co-ordinates of first empty cell in a grid (or null)\r\nconst getEmpty = (grid: IGrid): [number, number] | null => {\r\n    for(let row = 0; row < grid.grid.length; row++) {\r\n        for(let col = 0; col < grid.grid[row].length; col++) {\r\n            if(grid.grid[row][col].value === null) return [row, col];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nconst getCellBox = (cell: Coordinate, N: number): Coordinate => {\r\n    return [ Math.floor(cell[0]/N), Math.floor(cell[1]/N) ];\r\n}\r\n\r\nconst inSameBox = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    const [boxOne, boxTwo] = [getCellBox(one, N), getCellBox(two, N)];\r\n    return boxOne[0] === boxTwo[0] && boxOne[1] === boxTwo[1];\r\n}\r\n\r\nexport const cellsInSameRegion = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    return one[0] === two[0] || one[1] === two[1] || inSameBox(one, two, N);\r\n}\r\n\r\nexport const coordinatesEqual = (one: Coordinate, two: Coordinate): boolean => {\r\n    return one[0] === two[0] && one[1] === two[1];\r\n}\r\n\r\n// in place and returns the array\r\nexport const shuffle = (arr: any[]): any[] => {\r\n    for (let i = arr.length-1; i >= 0; i--) {\r\n        let j = Math.floor(Math.random() * (i+1));\r\n        [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport const solveGrid = (grid: IGrid, random: boolean, countAll: boolean): number => {\r\n    // TODO: keep track of empty cells in IGrid rather than re-calcing on every recurse\r\n    const empty = getEmpty(grid);\r\n    if(empty === null) return 1;\r\n\r\n    const [row, col] = empty;\r\n    let solutionsFromHere = 0;\r\n\r\n    // possible values for cell\r\n    const options: number[] = Array.from({length: grid.N*grid.N}, (_, i) => i+1); \r\n    if(random) shuffle(options);\r\n\r\n    for(const option of options) {\r\n        grid.grid[row][col].value = option;\r\n\r\n        if(!validGrid(grid)) continue;\r\n        const sols = solveGrid(grid, random, countAll);\r\n        \r\n        if(!countAll && sols === 1) return sols;\r\n\r\n        solutionsFromHere += sols;\r\n    }\r\n\r\n    grid.grid[row][col].value = null;\r\n    return solutionsFromHere;\r\n}\r\n\r\nexport const generateGrid = (grid: IGrid, emptyCells: number) => {\r\n\r\n    // Generate solved state and work backwards\r\n    console.log(solveGrid(grid, false, true));\r\n\r\n\r\n}\r\n\r\nexport const instantiateGrid = (N: number): IGrid => {\r\n    return {\r\n        N,\r\n        grid: Array.from({length: N*N}, (_, row) => (\r\n            Array.from({length: N*N}, (_, col) => ({value: null}))\r\n        ))\r\n    }\r\n}","import React, { useEffect, useState } from \"react\";\r\nimport { cellsInSameRegion, Coordinate, coordinatesEqual, generateGrid, instantiateGrid, solveGrid } from \"../Sudoku/Sudoku\";\r\nimport styles from './Grid.module.scss';\r\nvar classNames = require('classnames');\r\n\r\nexport interface GridProps {\r\n    N: number;\r\n}\r\n\r\nexport const Grid: React.FC<GridProps> = ({ N }) => {\r\n    const [ grid, setGrid ] = useState(instantiateGrid(N))\r\n    const [ selectedCell, setSelectedCell ] = useState<Coordinate>([0, 0]);\r\n\r\n    useEffect(() => {\r\n        // setGrid(curr => {\r\n        //     const newGrid = {N: curr.N, grid: curr.grid.map(a => a.slice())}\r\n        //     solveGrid(newGrid, true, false);\r\n        //     return newGrid;\r\n        // });\r\n    }, []);\r\n\r\n    const selectCell = (rowIdx: number, colIdx: number): void => {\r\n        setSelectedCell(currentCell => [rowIdx, colIdx]);\r\n    }\r\n\r\n    // Row by row\r\n    return <div className={styles.grid}>\r\n        {grid.grid.map((row, rowIdx) => <div className={styles.row} key={rowIdx}>{\r\n            row.map((cell, colIdx) => {\r\n                // state === 2 - selected coordinate\r\n                // state === 1 - same region (row, col, or box)\r\n                // state === 0 - unrelated cell\r\n                const state = coordinatesEqual(selectedCell, [rowIdx, colIdx]) ? 2 \r\n                            : (cellsInSameRegion(selectedCell, [rowIdx, colIdx], grid.N) ? 1\r\n                            : 0);\r\n                            \r\n                let cn = classNames(\r\n                    // Base style\r\n                    styles.cell,\r\n\r\n                    // Selected cell and region\r\n                    {[styles.selected_region]: state === 1},\r\n                    {[styles.selected_cell]: state === 2},\r\n\r\n                    // Borders\r\n                    {[styles.cell_top_border_soft]: rowIdx % grid.N !== 0},\r\n                    {[styles.cell_left_border_soft]: colIdx % grid.N !== 0},\r\n                    {[styles.cell_top_border_hard]: rowIdx % grid.N === 0},\r\n                    {[styles.cell_left_border_hard]: colIdx % grid.N === 0}, \r\n                );\r\n                return <div className={cn} key={`${rowIdx} ${colIdx}`} onMouseDown={() => selectCell(rowIdx, colIdx)}>\r\n                    {cell.value}\r\n                </div>}\r\n            )\r\n        }</div>)}\r\n    </div>\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './document.css';\nimport styles from './index.module.scss';\nimport { Grid } from './Grid/Grid';\n\nexport const App: React.FC = () => {\n \n  return <div className={styles.app}>\n    <Grid N={3}/>\n  </div>\n}\n\n// Inject\nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"src_app__71Sw-\"};"],"sourceRoot":""}