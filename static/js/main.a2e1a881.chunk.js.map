{"version":3,"sources":["Controls/Controls.module.scss","index.module.scss","Sudoku/Sudoku.ts","Grid/Grid.tsx","Controls/Controls.tsx","index.tsx","Grid/Grid.module.scss"],"names":["module","exports","isUniqueCellSet","cells","found","cell","value","some","c","push","getRow","grid","row","o","col","N","getCol","getBox","boxRow","boxCol","i","Math","floor","getCellBox","cellsInSameRegion","one","two","boxOne","boxTwo","inSameBox","getValueAtCoordinate","coord","validGrid","valueFrequencyInSet","arr","forEach","getEmptyMarks","Array","from","length","_","clearGridOfState","state","rowIdx","colIdx","marks","shuffle","j","random","fillGrid","generate","countAll","empty","getEmpty","solutionsFromHere","options","option","sols","generateGrid","emptyCells","getAllCoordinates","temp","shift","instantiateGrid","copyGrid","map","a","slice","classNames","require","arrowToNeighbour","Grid","controlFunctions","editModeState","testModeState","useState","Sudoku","setGrid","selectedCell","setSelectedCell","editMode","toggleEditMode","testMode","toggleTestMode","generateNewGrid","curr","newGrid","solveGrid","handleKeyDown","e","key","val","Number","prevent","Object","keys","includes","currentSelectedCell","newCell","isNaN","setCellValue","preventDefault","useEffect","document","addEventListener","removeEventListener","current","solve","loadCell","className","styles","shade","valueOne","cn","selected_cell","selected_number","selected_region","cell_static","cell_solved","cell_test","cell_invalid","cell_top_border_soft","cell_left_border_soft","cell_top_border_hard","cell_left_border_hard","onMouseDown","currentCell","selectCell","markRow","mark_row","markCol","mark_cell","Controls","action_button","onClick","FormControlLabel","control","Switch","checked","onChange","name","color","label","numberRow","numberCol","number_button","App","useRef","setEditMode","setTestMode","app","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.a2e1a881.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Controls_grid__1V3am\",\"row\":\"Controls_row__2zoL9\",\"action_button\":\"Controls_action_button__3Drga\",\"number_button\":\"Controls_number_button__nPbV3\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"src_app__71Sw-\"};","// Static means generated - unchanging\r\n// Solved means when you press \"solve\" it was filled in for you\r\n// Null means either empty or filled by the user (default)\r\nexport type CellState = 'static' | 'solved' | 'test' | null;\r\n\r\n// ICell, IGrid, I Fard, I Shid\r\nexport interface ICell {\r\n    value: number | null;\r\n    state: CellState;\r\n    marks: boolean[];\r\n}\r\n\r\nexport interface IGrid {\r\n    N: number; // N is the size of a box. The grid is a 3x3 set of boxes, essentially 3N by 3N.\r\n    grid: ICell[][];\r\n};\r\n\r\nexport type Coordinate = [row: number, col: number];\r\n\r\nconst isUniqueCellSet = (cells: ICell[]): boolean => {\r\n    const found: number[] = [];\r\n\r\n    for(const cell of cells) {\r\n        if(cell.value === null) continue;\r\n\r\n        // Duplicate found\r\n        if(found.some(c => c === cell.value)) return false;\r\n        \r\n        // If not already found, add it to the list\r\n        found.push(cell.value!);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Expanded from one-liners for readability\r\nconst getRow = (grid: IGrid, row: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let col = 0; col < grid.N*grid.N; col++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getCol = (grid: IGrid, col: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let row = 0; row < grid.N*grid.N; row++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getBox = (grid: IGrid, boxRow: number, boxCol: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        const [row, col] = [boxRow*grid.N+Math.floor(i/grid.N), boxCol*grid.N+i%grid.N];\r\n        o.push(grid.grid[row][col]);\r\n    }\r\n    return o;\r\n};\r\n\r\nexport const getCellBox = (cell: Coordinate, N: number): Coordinate => {\r\n    return [ Math.floor(cell[0]/N), Math.floor(cell[1]/N) ];\r\n}\r\n\r\nexport const inSameBox = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    const [boxOne, boxTwo] = [getCellBox(one, N), getCellBox(two, N)];\r\n    return boxOne[0] === boxTwo[0] && boxOne[1] === boxTwo[1];\r\n}\r\n\r\nexport const cellsInSameRegion = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    return one[0] === two[0] || one[1] === two[1] || inSameBox(one, two, N);\r\n}\r\n\r\nexport const coordinatesEqual = (one: Coordinate, two: Coordinate): boolean => {\r\n    return one[0] === two[0] && one[1] === two[1];\r\n}\r\n\r\nexport const getValueAtCoordinate = (coord: Coordinate, grid: IGrid): number | null => {\r\n    return grid.grid[coord[0]][coord[1]].value;\r\n}\r\n\r\nexport const cellValuesEqual = (one: Coordinate, two: Coordinate, grid: IGrid): boolean => {\r\n    const [valueOne, valueTwo] = [getValueAtCoordinate(one, grid), getValueAtCoordinate(two, grid)]\r\n    return valueOne !== null && valueOne === valueTwo;\r\n}\r\n\r\nexport const coordOOBOnGrid = (coord: Coordinate, grid: IGrid): boolean => {\r\n    return coord[0] < 0 || coord[1] < 0 || coord[0] >= grid.grid.length || coord[1] >= grid.grid[coord[0]].length;\r\n}\r\n\r\nexport const sumCoordinates = (one: Coordinate, two: Coordinate): Coordinate => {\r\n    return [one[0] + two[0], one[1] + two[1]];\r\n}\r\n\r\nexport const getAllCoordinates = (grid: IGrid): Coordinate[] => {\r\n    return Array.from({length: grid.N * grid.N*grid.N * grid.N}, (_, i) => [Math.floor(i/(grid.N*grid.N)), i%(grid.N*grid.N)]);\r\n}\r\n\r\nexport const validGrid = (grid: IGrid): boolean => {\r\n    // validate rows\r\n    for(let row = 0; row < grid.N*grid.N; row++) {\r\n        if(!isUniqueCellSet(getRow(grid, row))) return false;\r\n    }\r\n\r\n    // validate cols\r\n    for(let col = 0; col < grid.N*grid.N; col++) {\r\n        if(!isUniqueCellSet(getCol(grid, col))) return false;\r\n    }\r\n\r\n    // validate boxes\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        if(!isUniqueCellSet(getBox(grid, Math.floor(i/grid.N), i%grid.N))) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nconst valueFrequencyInSet = (arr: ICell[], value: number | null): number => {\r\n    let o = 0;\r\n    arr.forEach(i => {\r\n        if(i.value === value) o++;\r\n    })\r\n    \r\n    return o;\r\n}\r\n\r\nexport const isCoordinateValidOnGrid = (grid: IGrid, coord: Coordinate): boolean => {\r\n    return valueFrequencyInSet(getRow(grid, coord[0]), getValueAtCoordinate(coord, grid)) <= 1\r\n        && valueFrequencyInSet(getCol(grid, coord[1]), getValueAtCoordinate(coord, grid)) <= 1\r\n        && valueFrequencyInSet(getBox(grid, getCellBox(coord, grid.N)[0], getCellBox(coord, grid.N)[1]), getValueAtCoordinate(coord, grid)) <= 1;\r\n}\r\n\r\n// get co-ordinates of first empty cell in a grid (or null)\r\nexport const getEmpty = (grid: IGrid): [number, number] | null => {\r\n    for(let row = 0; row < grid.grid.length; row++) {\r\n        for(let col = 0; col < grid.grid[row].length; col++) {\r\n            if(grid.grid[row][col].value === null) return [row, col];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport const getEmptyMarks = (N: number): boolean[] => Array.from({length: N*N}, (_, i) => false);\r\n\r\nexport const clearGridOfState = (grid: IGrid, state: CellState) => {\r\n    grid.grid.forEach((row, rowIdx) => {\r\n        grid.grid[rowIdx].forEach((cell, colIdx) => {\r\n            if(grid.grid[rowIdx][colIdx].state === state) grid.grid[rowIdx][colIdx] = {value: null, state: null, marks: getEmptyMarks(grid.N)}; \r\n        });\r\n    });\r\n}\r\n\r\n// in place and returns the array\r\nexport const shuffle = (arr: any[]): any[] => {\r\n    for (let i = arr.length-1; i >= 0; i--) {\r\n        let j = Math.floor(Math.random() * (i+1));\r\n        [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport const fillGrid = (grid: IGrid, generate: boolean, countAll: boolean): number => {\r\n    // TODO: keep track of empty cells in IGrid rather than re-calcing on every recurse\r\n    const empty = getEmpty(grid);\r\n    if(empty === null) return 1;\r\n\r\n    const [row, col] = empty;\r\n    let solutionsFromHere = 0;\r\n\r\n    // possible values for cell\r\n    const options: number[] = Array.from({length: grid.N*grid.N}, (_, i) => i+1); \r\n    if(generate) shuffle(options);\r\n\r\n    for(const option of options) {\r\n        grid.grid[row][col] = {\r\n            value: option,\r\n            state: generate ? 'static' : 'solved',\r\n            marks: grid.grid[row][col].marks\r\n        };\r\n\r\n        if(!validGrid(grid)) continue;\r\n        const sols = fillGrid(grid, generate, countAll);\r\n        \r\n        if(!countAll && sols === 1) return sols;\r\n\r\n        solutionsFromHere += sols;\r\n    }\r\n\r\n    grid.grid[row][col] = {\r\n        value: null,\r\n        state: null,\r\n        marks: grid.grid[row][col].marks\r\n    };\r\n    \r\n    return solutionsFromHere;\r\n}\r\n\r\nexport const generateGrid = (grid: IGrid, emptyCells: number): void => {\r\n\r\n    // Generate solved state and work backwards\r\n    fillGrid(grid, true, false);\r\n\r\n    const options: Coordinate[] = shuffle(getAllCoordinates(grid));\r\n    \r\n    // While there are more empty cells to remove and we haven't run out of options\r\n    while(emptyCells > 0 && options.length > 0) {\r\n\r\n        // Remove the cell at our first (random) location and store temporarily\r\n        const temp = grid.grid[options[0][0]][options[0][1]].value;\r\n        grid.grid[options[0][0]][options[0][1]] = {value: null, state: null, marks: getEmptyMarks(grid.N)};\r\n        \r\n        // Not a valid solution\r\n        if(fillGrid(grid, false, true) !== 1) {\r\n            // Restore value if it introduces ambiguity\r\n            grid.grid[options[0][0]][options[0][1]] = {value: temp, state: 'static', marks: getEmptyMarks(grid.N)};\r\n        } else {\r\n            // Decrease the number of empty cells (remaining)\r\n            emptyCells--;\r\n\r\n            // Clear the board of solved cells (they would have been filled in when we checked)\r\n            clearGridOfState(grid, 'solved');\r\n        }\r\n\r\n        // Remove the option\r\n        options.shift();\r\n    }\r\n}\r\n\r\nexport const instantiateGrid = (N: number): IGrid => {\r\n    return {\r\n        N,\r\n        grid: Array.from({length: N*N}, (_, row) => (\r\n            Array.from({length: N*N}, (_, col) => ({ value: null, state: null, marks: getEmptyMarks(N) }))\r\n        ))\r\n    }\r\n}\r\n\r\nexport const copyGrid = (grid: IGrid): IGrid => {\r\n    return {\r\n        N: grid.N, \r\n        grid: grid.grid.map(a => a.slice())\r\n    }\r\n}","import React, { useEffect, useState } from \"react\";\r\nimport { IControlFunctions } from \"../ControlFunctions\";\r\nimport * as Sudoku from \"../Sudoku/Sudoku\";\r\nimport styles from './Grid.module.scss';\r\nvar classNames = require('classnames');\r\n\r\nexport interface GridProps {\r\n    N: number;\r\n    controlFunctions: React.MutableRefObject<IControlFunctions>;\r\n    editModeState: [editMode: boolean, toggleEditMode: () => void];\r\n    testModeState: [testMode: boolean, toggleTestMode: () => void];\r\n}\r\n\r\ninterface ATM { [key: string]: Sudoku.Coordinate }\r\n\r\nconst arrowToNeighbour: ATM = {\r\n    'ArrowUp':      [-1, 0],\r\n    'ArrowDown':    [1, 0],\r\n    'ArrowLeft':    [0, -1],\r\n    'ArrowRight':   [0, 1],\r\n};\r\n\r\nexport const Grid: React.FC<GridProps> = ({ N, controlFunctions, editModeState, testModeState }) => {\r\n    const [ grid, setGrid ] = useState(Sudoku.instantiateGrid(N))\r\n    const [ selectedCell, setSelectedCell ] = useState<Sudoku.Coordinate>([0, 0]);\r\n    const [ editMode, toggleEditMode ] = editModeState;\r\n    const [ testMode, toggleTestMode ] = testModeState;\r\n\r\n    const generateNewGrid = (): void => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.instantiateGrid(curr.N);\r\n            Sudoku.generateGrid(newGrid, 50);\r\n            return newGrid;\r\n        });\r\n    }\r\n\r\n    const solveGrid = (): void => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.copyGrid(curr);\r\n            Sudoku.fillGrid(newGrid, false, false);\r\n            return newGrid;\r\n        });\r\n    }\r\n\r\n    const moveAccordingToKey = (key: string): void => {\r\n        setSelectedCell(currentSelectedCell => {\r\n            const newCell = Sudoku.sumCoordinates(currentSelectedCell, arrowToNeighbour[key]);\r\n            if(Sudoku.coordOOBOnGrid(newCell, grid)) return currentSelectedCell;\r\n            return newCell;\r\n        })\r\n    }\r\n\r\n    const handleKeyDown = (e: KeyboardEvent): void => {\r\n        const val = Number(e.key);\r\n        let prevent = true;\r\n\r\n        if(Object.keys(arrowToNeighbour).includes(e.key)) moveAccordingToKey(e.key);\r\n        else if(!isNaN(val) && e.key !== ' ') setCellValue(selectedCell[0], selectedCell[1], val); \r\n        else if(e.key === 'Delete' || e.key === 'Backspace') setCellValue(selectedCell[0], selectedCell[1], null);\r\n        else if(e.key === ' ') solveGrid(); \r\n        else if(e.key === 'e') toggleEditMode();\r\n        else if(e.key === 't') toggleTestMode();\r\n        else {\r\n            prevent  = false;\r\n            // console.log(e.key);\r\n        }\r\n\r\n        if(prevent) e.preventDefault();\r\n    }\r\n\r\n    useEffect(() => { generateNewGrid(); }, [])\r\n\r\n    useEffect(() => {\r\n        document.addEventListener('keydown', handleKeyDown);\r\n\r\n        return () => document.removeEventListener('keydown', handleKeyDown)\r\n    }, [ selectedCell, editMode, testMode ]);\r\n\r\n    const selectCell = (row: number, col: number): void => {\r\n        setSelectedCell(currentCell => [row, col]);\r\n    }\r\n\r\n    const setCellValue = (row: number, col: number, value: number | null): void => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.copyGrid(curr);\r\n\r\n            if(newGrid.grid[row][col].state === 'static') return newGrid;\r\n            \r\n             if(!editMode) {\r\n                const currVal = Sudoku.getValueAtCoordinate([row, col], newGrid);\r\n                if(currVal === value || value === 0) newGrid.grid[row][col].value = null;\r\n                else {\r\n                    newGrid.grid[row][col].value = value;\r\n                    newGrid.grid[row][col].state = testMode ? 'test' : null;\r\n                }\r\n            } else if(value !== null && value !== 0) {\r\n                newGrid.grid[row][col].marks[value-1] = !newGrid.grid[row][col].marks[value-1];\r\n            }\r\n            \r\n            return newGrid;\r\n        });\r\n    }\r\n\r\n    controlFunctions.current.generate = generateNewGrid;\r\n    controlFunctions.current.solve = solveGrid;\r\n    controlFunctions.current.loadCell = (value: number) => { setCellValue(selectedCell[0], selectedCell[1], value); };\r\n\r\n    // Row by row\r\n    return <div className={styles.grid}>\r\n        {grid.grid.map((row, rowIdx) => <div className={styles.row} key={rowIdx}>{\r\n            row.map((cell, colIdx) => {\r\n                \r\n                const shade = Sudoku.coordinatesEqual(selectedCell, [rowIdx, colIdx]) ? 'coordinate'\r\n                            : Sudoku.cellValuesEqual(selectedCell, [rowIdx, colIdx], grid) ? 'number'\r\n                            : Sudoku.cellsInSameRegion(selectedCell, [rowIdx, colIdx], grid.N) ? 'region'\r\n                            : null;\r\n\r\n                const state = Sudoku.isCoordinateValidOnGrid(grid, [rowIdx, colIdx]) ? cell.state\r\n                            : 'invalid';\r\n                            \r\n                let cn = classNames(\r\n                    // Base style\r\n                    styles.cell,\r\n\r\n                    // Selected cell and region\r\n                    {[styles.selected_cell]: shade === 'coordinate'},\r\n                    {[styles.selected_number]: shade === 'number'},\r\n                    {[styles.selected_region]: shade === 'region'},\r\n\r\n                    // Cell type\r\n                    {[styles.cell_static]: state === 'static'},\r\n                    {[styles.cell_solved]: state === 'solved'},\r\n                    {[styles.cell_test]: state === 'test'},\r\n                    {[styles.cell_invalid]: state === 'invalid'},\r\n\r\n                    // Borders\r\n                    {[styles.cell_top_border_soft]: rowIdx % grid.N !== 0},\r\n                    {[styles.cell_left_border_soft]: colIdx % grid.N !== 0},\r\n                    {[styles.cell_top_border_hard]: rowIdx % grid.N === 0},\r\n                    {[styles.cell_left_border_hard]: colIdx % grid.N === 0}, \r\n                );\r\n                \r\n                return <div className={cn} key={`${rowIdx} ${colIdx}`} onMouseDown={() => selectCell(rowIdx, colIdx)}>\r\n                    {cell.value !== null ? cell.value : Array.from({ length: grid.N }, (_, markRow) => <div className={styles.mark_row} key={`${rowIdx} ${colIdx} ${markRow}`}>\r\n                        {Array.from({ length: grid.N }, (_, markCol) => <div className={styles.mark_cell} key={`${rowIdx} ${colIdx} ${markRow} ${markCol}`}>\r\n                            {cell.marks[markRow*grid.N+markCol] ? (markRow*grid.N+markCol)+1 : ' '}\r\n                        </div>)}\r\n                    </div>)}\r\n                </div>}\r\n            )\r\n        }</div>)}\r\n    </div>\r\n}","import { FormControlLabel, Switch } from \"@material-ui/core\";\r\nimport React, { useRef } from \"react\";\r\nimport { IControlFunctions } from \"../ControlFunctions\";\r\nimport styles from './Controls.module.scss';\r\nvar classNames = require('classnames');\r\n\r\nexport interface ControlsProps {\r\n    N: number;\r\n    controlFunctions: React.MutableRefObject<IControlFunctions>;\r\n    editModeState: [editMode: boolean, toggleEditMode: () => void];\r\n    testModeState: [testMode: boolean, toggleTestMode: () => void];\r\n}\r\n\r\nexport const Controls: React.FC<ControlsProps> = ({ N, controlFunctions, editModeState, testModeState }) => {\r\n    const [ editMode, toggleEditMode ] = editModeState;\r\n    const [ testMode, toggleTestMode ] = testModeState;\r\n\r\n    return <div className={styles.grid}>\r\n        <div className={styles.row}>\r\n            <button className={styles.action_button} onClick={() => controlFunctions.current?.generate && controlFunctions.current.generate()}>Generate</button>\r\n            <button className={styles.action_button} onClick={() => controlFunctions.current?.solve && controlFunctions.current.solve()}>Solve</button>\r\n        </div>\r\n        <div className={styles.row}>\r\n            <FormControlLabel\r\n                control={\r\n                <Switch\r\n                    checked={editMode}\r\n                    onChange={toggleEditMode}\r\n                    name=\"checkedB\"\r\n                    color=\"primary\"\r\n                />\r\n                }\r\n                label=\"Edit\"\r\n            />\r\n            <FormControlLabel\r\n                control={\r\n                <Switch\r\n                    checked={testMode}\r\n                    onChange={toggleTestMode}\r\n                    name=\"checkedB\"\r\n                    color=\"primary\"\r\n                />\r\n                }\r\n                label=\"Test\"\r\n            />\r\n        </div>\r\n        {Array.from({length: N}, (_, numberRow) => <div className={styles.row} key={numberRow}>\r\n            {Array.from({length: N}, (_, numberCol) => <div className={styles.cell} key={`${numberRow} ${numberCol}`}>\r\n            <button \r\n                className={styles.number_button} \r\n                onClick={() => controlFunctions.current?.loadCell && controlFunctions.current.loadCell(numberRow*N+numberCol+1)} \r\n                key={numberRow*N+numberCol+1}\r\n            >\r\n                {numberRow*N+numberCol+1}\r\n            </button>\r\n            </div>)}\r\n        </div>)}\r\n    </div>\r\n}","import React, { useRef, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './document.css';\nimport styles from './index.module.scss';\nimport { Grid } from './Grid/Grid';\nimport { Controls } from './Controls/Controls';\nimport { IControlFunctions } from './ControlFunctions';\n\nexport const App: React.FC = () => {\n  const controlFunctions = useRef<IControlFunctions>({ });\n  const [ editMode, setEditMode ] = useState<boolean>(false);\n  const [ testMode, setTestMode ] = useState<boolean>(false);\n\n  const toggleEditMode = () => { setEditMode(e => !e); }\n  const toggleTestMode = () => { setTestMode(e => !e); }\n  \n  const N = 3;\n  return <div className={styles.app}>\n    <Grid N={N} controlFunctions={controlFunctions} editModeState={[editMode, toggleEditMode]} testModeState={[testMode, toggleTestMode]} />\n    <Controls N={N} controlFunctions={controlFunctions} editModeState={[editMode, toggleEditMode]} testModeState={[testMode, toggleTestMode]} />\n  </div>\n}\n\n// Inject\nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Grid_grid__1_G_b\",\"row\":\"Grid_row__2i5tn\",\"cell\":\"Grid_cell__2Qb8m\",\"selected_cell\":\"Grid_selected_cell__anmyI\",\"selected_region\":\"Grid_selected_region__UIGkt\",\"selected_number\":\"Grid_selected_number__ACSJx\",\"cell_static\":\"Grid_cell_static__a53Fw\",\"cell_solved\":\"Grid_cell_solved__2rcXD\",\"cell_test\":\"Grid_cell_test__2ZzjS\",\"cell_invalid\":\"Grid_cell_invalid__qYQ_B\",\"cell_left_border_soft\":\"Grid_cell_left_border_soft__3V9ja\",\"cell_top_border_soft\":\"Grid_cell_top_border_soft__3woQe\",\"cell_left_border_hard\":\"Grid_cell_left_border_hard__1BuMv\",\"cell_top_border_hard\":\"Grid_cell_top_border_hard__32fsp\",\"mark_row\":\"Grid_mark_row__3PPpu\",\"mark_cell\":\"Grid_mark_cell__2oxgr\"};"],"sourceRoot":""}