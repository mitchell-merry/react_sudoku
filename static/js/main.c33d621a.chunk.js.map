{"version":3,"sources":["Grid/Grid.module.scss","Sudoku/Sudoku.ts","Grid/Grid.tsx","index.tsx","index.module.scss"],"names":["module","exports","isUniqueCellSet","cells","found","cell","value","some","c","push","getRow","grid","row","o","col","N","getCol","getBox","boxRow","boxCol","i","Math","floor","validGrid","getCellBox","cellsInSameRegion","one","two","boxOne","boxTwo","inSameBox","getValueAtCoordinate","coord","clearGridOfState","state","forEach","rowIdx","colIdx","shuffle","arr","length","j","random","fillGrid","generate","countAll","empty","getEmpty","solutionsFromHere","options","Array","from","_","option","sols","generateGrid","emptyCells","getAllCoordinates","temp","shift","console","log","copyGrid","map","a","slice","classNames","require","arrowToNeighbour","Grid","useState","Sudoku","setGrid","selectedCell","setSelectedCell","handleKeyDown","e","val","Number","key","isNaN","Object","keys","includes","currentSelectedCell","newCell","preventDefault","setCellValue","useEffect","curr","newGrid","document","addEventListener","removeEventListener","currVal","className","styles","shade","valueOne","cn","selected_cell","selected_number","selected_region","cell_static","cell_solved","cell_top_border_soft","cell_left_border_soft","cell_top_border_hard","cell_left_border_hard","onMouseDown","currentCell","selectCell","App","app","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.c33d621a.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"grid\":\"Grid_grid__1_G_b\",\"row\":\"Grid_row__2i5tn\",\"cell\":\"Grid_cell__2Qb8m\",\"selected_cell\":\"Grid_selected_cell__anmyI\",\"selected_region\":\"Grid_selected_region__UIGkt\",\"selected_number\":\"Grid_selected_number__ACSJx\",\"cell_static\":\"Grid_cell_static__a53Fw\",\"cell_solved\":\"Grid_cell_solved__2rcXD\",\"cell_left_border_soft\":\"Grid_cell_left_border_soft__3V9ja\",\"cell_top_border_soft\":\"Grid_cell_top_border_soft__3woQe\",\"cell_left_border_hard\":\"Grid_cell_left_border_hard__1BuMv\",\"cell_top_border_hard\":\"Grid_cell_top_border_hard__32fsp\"};","export type CellState = 'static' | 'solved' | null;\r\n\r\n// ICell, IGrid, I Fard, I Shid\r\nexport interface ICell {\r\n    value: number | null;\r\n    // Static means generated - unchanging\r\n    // Solved means when you press \"solve\" it was filled in for you\r\n    // Null means either empty or filled by the user (default)\r\n    state: CellState;\r\n}\r\n\r\nexport interface IGrid {\r\n    N: number; // N is the size of a box. The grid is a 3x3 set of boxes, essentially 3N by 3N.\r\n    grid: ICell[][];\r\n};\r\n\r\nexport type Coordinate = [row: number, col: number];\r\n\r\nconst isUniqueCellSet = (cells: ICell[]): boolean => {\r\n    const found: number[] = [];\r\n\r\n    for(const cell of cells) {\r\n        if(cell.value === null) continue;\r\n\r\n        // Duplicate found\r\n        if(found.some(c => c === cell.value)) return false;\r\n        \r\n        // If not already found, add it to the list\r\n        found.push(cell.value!);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// Expanded from one-liners for readability\r\nconst getRow = (grid: IGrid, row: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let col = 0; col < grid.N*grid.N; col++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getCol = (grid: IGrid, col: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let row = 0; row < grid.N*grid.N; row++) o.push(grid.grid[row][col]);\r\n    return o;\r\n};\r\n\r\nconst getBox = (grid: IGrid, boxRow: number, boxCol: number): ICell[] => {\r\n    const o: ICell[] = [];\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        const [row, col] = [boxRow*grid.N+Math.floor(i/grid.N), boxCol*grid.N+i%grid.N];\r\n        o.push(grid.grid[row][col]);\r\n    }\r\n    return o;\r\n};\r\n\r\nexport const validGrid = (grid: IGrid): boolean => {\r\n    // validate rows\r\n    for(let row = 0; row < grid.N*grid.N; row++) {\r\n        if(!isUniqueCellSet(getRow(grid, row))) return false;\r\n    }\r\n\r\n    // validate cols\r\n    for(let col = 0; col < grid.N*grid.N; col++) {\r\n        if(!isUniqueCellSet(getCol(grid, col))) return false;\r\n    }\r\n\r\n    // validate boxes\r\n    for(let i = 0; i < grid.N*grid.N; i++) {\r\n        if(!isUniqueCellSet(getBox(grid, Math.floor(i/grid.N), i%grid.N))) return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n// get co-ordinates of first empty cell in a grid (or null)\r\nexport const getEmpty = (grid: IGrid): [number, number] | null => {\r\n    for(let row = 0; row < grid.grid.length; row++) {\r\n        for(let col = 0; col < grid.grid[row].length; col++) {\r\n            if(grid.grid[row][col].value === null) return [row, col];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport const getCellBox = (cell: Coordinate, N: number): Coordinate => {\r\n    return [ Math.floor(cell[0]/N), Math.floor(cell[1]/N) ];\r\n}\r\n\r\nexport const inSameBox = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    const [boxOne, boxTwo] = [getCellBox(one, N), getCellBox(two, N)];\r\n    return boxOne[0] === boxTwo[0] && boxOne[1] === boxTwo[1];\r\n}\r\n\r\nexport const cellsInSameRegion = (one: Coordinate, two: Coordinate, N: number): boolean => {\r\n    return one[0] === two[0] || one[1] === two[1] || inSameBox(one, two, N);\r\n}\r\n\r\nexport const coordinatesEqual = (one: Coordinate, two: Coordinate): boolean => {\r\n    return one[0] === two[0] && one[1] === two[1];\r\n}\r\n\r\nexport const getValueAtCoordinate = (coord: Coordinate, grid: IGrid): number | null => {\r\n    return grid.grid[coord[0]][coord[1]].value;\r\n}\r\n\r\nexport const cellValuesEqual = (one: Coordinate, two: Coordinate, grid: IGrid): boolean => {\r\n    const [valueOne, valueTwo] = [getValueAtCoordinate(one, grid), getValueAtCoordinate(two, grid)]\r\n    return valueOne !== null && valueOne === valueTwo;\r\n}\r\n\r\nexport const coordOOBOnGrid = (coord: Coordinate, grid: IGrid): boolean => {\r\n    return coord[0] < 0 || coord[1] < 0 || coord[0] >= grid.grid.length || coord[1] >= grid.grid[coord[0]].length;\r\n}\r\n\r\nexport const sumCoordinates = (one: Coordinate, two: Coordinate): Coordinate => {\r\n    return [one[0] + two[0], one[1] + two[1]];\r\n}\r\n\r\nexport const getAllCoordinates = (grid: IGrid): Coordinate[] => {\r\n    return Array.from({length: grid.N * grid.N*grid.N * grid.N}, (_, i) => [Math.floor(i/(grid.N*grid.N)), i%(grid.N*grid.N)]);\r\n}\r\n\r\nexport const clearGridOfState = (grid: IGrid, state: CellState) => {\r\n    grid.grid.forEach((row, rowIdx) => {\r\n        grid.grid[rowIdx].forEach((cell, colIdx) => {\r\n            if(grid.grid[rowIdx][colIdx].state === state) grid.grid[rowIdx][colIdx] = {value: null, state: null}; \r\n        });\r\n    });\r\n}\r\n\r\n// in place and returns the array\r\nexport const shuffle = (arr: any[]): any[] => {\r\n    for (let i = arr.length-1; i >= 0; i--) {\r\n        let j = Math.floor(Math.random() * (i+1));\r\n        [arr[i], arr[j]] = [arr[j], arr[i]];\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport const fillGrid = (grid: IGrid, generate: boolean, countAll: boolean): number => {\r\n    // TODO: keep track of empty cells in IGrid rather than re-calcing on every recurse\r\n    const empty = getEmpty(grid);\r\n    if(empty === null) return 1;\r\n\r\n    const [row, col] = empty;\r\n    let solutionsFromHere = 0;\r\n\r\n    // possible values for cell\r\n    const options: number[] = Array.from({length: grid.N*grid.N}, (_, i) => i+1); \r\n    if(generate) shuffle(options);\r\n\r\n    for(const option of options) {\r\n        grid.grid[row][col] = {\r\n            value: option,\r\n            state: generate ? 'static' : 'solved'\r\n        };\r\n\r\n        if(!validGrid(grid)) continue;\r\n        const sols = fillGrid(grid, generate, countAll);\r\n        \r\n        if(!countAll && sols === 1) return sols;\r\n\r\n        solutionsFromHere += sols;\r\n    }\r\n\r\n    grid.grid[row][col] = {\r\n        value: null,\r\n        state: null\r\n    };\r\n    \r\n    return solutionsFromHere;\r\n}\r\n\r\nexport const generateGrid = (grid: IGrid, emptyCells: number): void => {\r\n\r\n    // Generate solved state and work backwards\r\n    fillGrid(grid, true, false);\r\n\r\n    const options: Coordinate[] = shuffle(getAllCoordinates(grid));\r\n    \r\n    // While there are more empty cells to remove and we haven't run out of options\r\n    while(emptyCells > 0 && options.length > 0) {\r\n\r\n        // Remove the cell at our first (random) location and store temporarily\r\n        const temp = grid.grid[options[0][0]][options[0][1]].value;\r\n        grid.grid[options[0][0]][options[0][1]] = {value: null, state: null};\r\n        \r\n        // Not a valid solution\r\n        if(fillGrid(grid, false, true) !== 1) {\r\n            // Restore value if it introduces ambiguity\r\n            grid.grid[options[0][0]][options[0][1]] = {value: temp, state: 'static'};\r\n        } else {\r\n            // Decrease the number of empty cells (remaining)\r\n            emptyCells--;\r\n            // Clear the board of solved cells (they would have been filled in when we checked)\r\n            clearGridOfState(grid, 'solved');\r\n        }\r\n\r\n        options.shift();\r\n    }\r\n\r\n    console.log(grid)\r\n}\r\n\r\nexport const instantiateGrid = (N: number): IGrid => {\r\n    return {\r\n        N,\r\n        grid: Array.from({length: N*N}, (_, row) => (\r\n            Array.from({length: N*N}, (_, col) => ({ value: null, state: null }))\r\n        ))\r\n    }\r\n}\r\n\r\nexport const copyGrid = (grid: IGrid): IGrid => {\r\n    return {\r\n        N: grid.N, \r\n        grid: grid.grid.map(a => a.slice())\r\n    }\r\n}","import React, { useEffect, useState } from \"react\";\r\nimport * as Sudoku from \"../Sudoku/Sudoku\";\r\nimport styles from './Grid.module.scss';\r\nvar classNames = require('classnames');\r\n\r\nexport interface GridProps {\r\n    N: number;\r\n}\r\n\r\ninterface ATM { [key: string]: Sudoku.Coordinate }\r\n\r\nconst arrowToNeighbour: ATM = {\r\n    'ArrowUp':      [-1, 0],\r\n    'ArrowDown':    [1, 0],\r\n    'ArrowLeft':    [0, -1],\r\n    'ArrowRight':   [0, 1],\r\n};\r\n\r\nexport const Grid: React.FC<GridProps> = ({ N }) => {\r\n    const [ grid, setGrid ] = useState(Sudoku.instantiateGrid(N))\r\n    const [ selectedCell, setSelectedCell ] = useState<Sudoku.Coordinate>([0, 0]);\r\n\r\n    const handleKeyDown = (e: KeyboardEvent): void => {\r\n        const val = Number(e.key);\r\n        if(!isNaN(val)) {\r\n            e.preventDefault();    \r\n            setCellValue(selectedCell[0], selectedCell[1], val);\r\n        } else if(Object.keys(arrowToNeighbour).includes(e.key)) {\r\n            setSelectedCell(currentSelectedCell => {\r\n                const newCell = Sudoku.sumCoordinates(currentSelectedCell, arrowToNeighbour[e.key]);\r\n                if(Sudoku.coordOOBOnGrid(newCell, grid)) return currentSelectedCell\r\n                return newCell;\r\n            })\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.copyGrid(curr);\r\n            Sudoku.generateGrid(newGrid, 45);\r\n            return newGrid;\r\n        });\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        document.addEventListener('keydown', handleKeyDown);\r\n\r\n        return () => document.removeEventListener('keydown', handleKeyDown)\r\n    }, [ selectedCell, ]);\r\n\r\n    const selectCell = (row: number, col: number): void => {\r\n        setSelectedCell(currentCell => [row, col]);\r\n    }\r\n\r\n    const setCellValue = (row: number, col: number, value: number): void => {\r\n        setGrid(curr => {\r\n            const newGrid = Sudoku.copyGrid(curr);\r\n\r\n            if(newGrid.grid[row][col].state !== 'static') {\r\n                const currVal = Sudoku.getValueAtCoordinate([row, col], newGrid);\r\n                if(currVal === value || value === 0) newGrid.grid[row][col].value = null;\r\n                else newGrid.grid[row][col].value = value;\r\n            }\r\n            \r\n            return newGrid;\r\n        });\r\n    }\r\n\r\n    // Row by row\r\n    return <div className={styles.grid}>\r\n        {grid.grid.map((row, rowIdx) => <div className={styles.row} key={rowIdx}>{\r\n            row.map((cell, colIdx) => {\r\n                \r\n                const shade = Sudoku.coordinatesEqual(selectedCell, [rowIdx, colIdx]) ? 'coordinate'\r\n                            : Sudoku.cellValuesEqual(selectedCell, [rowIdx, colIdx], grid) ? 'number'\r\n                            : Sudoku.cellsInSameRegion(selectedCell, [rowIdx, colIdx], grid.N) ? 'region'\r\n                            : null;\r\n                            \r\n                let cn = classNames(\r\n                    // Base style\r\n                    styles.cell,\r\n\r\n                    // Selected cell and region\r\n                    {[styles.selected_cell]: shade === 'coordinate'},\r\n                    {[styles.selected_number]: shade === 'number'},\r\n                    {[styles.selected_region]: shade === 'region'},\r\n\r\n                    // Cell type\r\n                    {[styles.cell_static]: cell.state === 'static'},\r\n                    {[styles.cell_solved]: cell.state === 'solved'},\r\n\r\n                    // Borders\r\n                    {[styles.cell_top_border_soft]: rowIdx % grid.N !== 0},\r\n                    {[styles.cell_left_border_soft]: colIdx % grid.N !== 0},\r\n                    {[styles.cell_top_border_hard]: rowIdx % grid.N === 0},\r\n                    {[styles.cell_left_border_hard]: colIdx % grid.N === 0}, \r\n                );\r\n                \r\n                return <div className={cn} key={`${rowIdx} ${colIdx}`} onMouseDown={() => selectCell(rowIdx, colIdx)}>\r\n                    {cell.value}\r\n                </div>}\r\n            )\r\n        }</div>)}\r\n    </div>\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './document.css';\nimport styles from './index.module.scss';\nimport { Grid } from './Grid/Grid';\n\nexport const App: React.FC = () => {\n \n  return <div className={styles.app}>\n    <Grid N={3}/>\n  </div>\n}\n\n// Inject\nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"src_app__71Sw-\"};"],"sourceRoot":""}